<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Arkscript | Tutorials - Embedding</title>
    <link rel="stylesheet" href="/assets/css/spectre.min.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/spectre-icons.min.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/rainbowjs-theme.css" type="text/css">
    <link rel="stylesheet" href="/assets/css/main.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<!-- HEADER -->
<header class="navbar">
    <a href="#" class="btn btn-link show-xl" tabindex="0" id="menu-show"><i class="icon icon-menu"></i></a>
    <section class="navbar-section show-on-focus hide-xl">
        <a href="/" class="navbar-brand mr-2 hide-xl">ArkScript</a>
        <a href="/" class="btn btn-link">Home</a>
        <a href="/documentation.html" class="btn btn-link">Documentation</a>
        <a href="/contributing.html" class="btn btn-link">Contributing</a>
        <div class="dropdown">
            <a href="#" class="btn btn-link dropdown-toggle" tabindex="0">Tutorials</a>
            <ul class="menu">
                <li><a href="/tutorials/basics.html" class="btn btn-link">Basics</a></li>
                <li><a href="/tutorials/building.html" class="btn btn-link">Building</a></li>
                <li><a href="/tutorials/embedding.html" class="btn btn-link">Embedding</a></li>
                <li><a href="/tutorials/bytecode.html" class="btn btn-link">Bytecode</a></li>
            </ul>
        </div>
        <a href="https://github.com/ArkScript-lang/Ark" class="btn btn-link">Github</a>
        <a href="https://discord.gg/YT5yDwn" class="btn btn-link">Discord</a>
    </section>
    <section class="navbar-section logo">
        <a href="/"><img src="/assets/images/Ark-slim.png" alt="ArkScript"></a>
    </section>
</header>

<!-- CONTENT -->
<div class="container" id="main">
    <div class="columns">
        <!-- The col-2 divs are an easy way to put some margin around the main content -->
        <div class="col-2 hide-md"></div>

        <!-- Actual content of the page-->
        <div class="col-8 col-md-12" id="content">
            <h1 class="text-center">Tutorials - Embedding</h1>

            ArkScript was designed to be easily embedded into C++ applications, so here you go!
            <br><br><br>

            <section id="adding-to-project">
                <h2>Adding ArkScript to your project</h2>

                <div class="inner-content">
                    If you are <em class="text-bold">not</em> building the project with CMake: download CMake,
                    create a CMakeLists.txt for your project, and then follow the instructions.

                    <ol>
                        <li>
                            Setting the compilation options:
                            <ul>
                                <li>If you don't want Ark.exe: <code>set(ARK_BUILD_EXE Off)</code></li>
                                <li>If you don't want to build the modules: <code>set(ARK_BUILD_MODULES Off)</code></li>
                                <li>If you want to disable the use of <code>(system "command that can break your pc here")</code>: <code>set(ARK_ENABLE_SYSTEM 0)</code></li>
                            </ul>
                        </li>
                        <li>
                            Add this line to your main CMakeLists.txt: <code>add_subdirectory(ark-directory)</code>
                            (put the path to the ArkScript directory, where a CMakeLists.txt is);
                            the include directories should come without having to do anything on your side
                        </li>
                        <li>
                            Link your project to the lib produced by ArkScript:
                            <code>target_link_library(${PROJECT_NAME} PUBLIC ArkReactor)</code>
                            (modify the privacy according to what you chosed in your project)
                        </li>
                        <li>You're good to go! Everything you need will be available through <code>#include &lt;Ark/Ark.hpp&gt;</code></li>
                    </ol>
                </div>
            </section>

            <section id="using-arkscript">
                <h2>Using ArkScript</h2>

                <div class="inner-section">
                    An example is often worth a thousand words:
                    <pre>
<code class="rainbowjs" data-language="c">
#include &lt;Ark/Ark.hpp&gt;

int main()
{
    // A state can be shared by multiple virtual machines (note that they will NEVER modify it)
    // leave constructor empty to select the default standard library (loaded from an environment variable $ARKSCRIPT_PATH/lib)
    // persistance is needed to use vm.call(function_name, args...)
    Ark::State state(/* options */ Ark::FeaturePersist);

    // Will automatically compile the file if needed (if not, will take it from the ark cache)
    state.doFile("myfile.ark");

    Ark::VM vm(&state);
    vm.run();

    /*
        If you just want to run a precompiled bytecode file:

        Ark::State state;
        state.feed("mybytecode.arkc");
        Ark::VM vm(&state);
        vm.run();
    */

    /*
        To run an ArkScript function from C++ code and retrieve the result:
        we will say the code is (let foo (fun (x y) (+ x y 2)))
    */
    auto value = vm.call("foo", 5, 6.0);
    std::cout << value << "\n";  // displays 13

    return 0;
}
</code>
                    </pre>
                </div>
            </section>

            <section id="adding-functions">
                <h2>Adding your own functions in ArkScript</h2>

                <div class="inner-section">
                    <pre>
<code class="rainbowjs" data-language="c">
#include &lt;Ark/Ark.hpp&gt;

Ark::Value my_function(std::vector&lt;Ark::Value&gt;& args)
{
    // checking argument number
    if (args.size() != 4)
        throw std::runtime_error("my_function needs 4 arguments!");

    auto a = args[0],
        b = args[1],
        c = args[2],
        d = args[3];

    // checking arguments type
    if (a.valueType() != Ark::ValueType::Number ||
        b.valueType() != Ark::ValueType::Number ||
        c.valueType() != Ark::ValueType::Number ||
        d.valueType() != Ark::ValueType::Number)
        throw Ark::TypeError("Type mismatch for my_function: need only numbers");

    // type is automatically deducted from the argument
    return Ark::Value(a.number() * b.number() - c.number() / d.number());
}

int main()
{
    Ark::State state(/* options */ Ark::FeaturePersist);
    state.doFile("myfile.ark");  // we can call state.doFile() before or after state.loadFunction()

    state.loadFunction("my_function", my_function);

    // we can also load C++ lambdas
    // we could have done this after creating the VM, it would still works
    // we just need to do that BEFORE we call vm.run()
    state.loadFunction("foo", [](std::vector&lt;Ark::Value&gt;& args) {
        return Ark::Value(static_cast&lt;int&gt;(args.size()));
    });

    Ark::VM vm(&state);
    vm.run();

    return 0;
}
</code>
                    </pre>
                </div>
            </section>

            <section id="details-value-type">
                <h2>Details on the Value type</h2>

                <div class="inner-section">
                    Types available in <code>Ark::ValueType</code> are:
                    <ul>
                        <li><code>List</code></li>
                        <li><code>Number</code></li>
                        <li><code>String</code></li>
                        <li><code>PageAddr</code> (reprensents the address of an ArkScript function in the bytecode)</li>
                        <li><code>NFT</code> (the triad Nil, False, True)</li>
                        <li><code>CProc</code> (C or C++ functions)</li>
                        <li><code>Closure</code> (represents a closure in ArkScript)</li>
                        <li><code>User</code> (represents a type defined by the user)</li>
                    </ul>

                    <code>Value</code> objects have this interface:
                    <ul>
                        <li><code>ValueType valueType() const</code> to get the type of the value held</li>
                        <li>
                            The following methods allow to retrieve the data held by the object,
                            but if the type doesn't match, it's an undefined behavior:
                            <ul>
                                <li><code>double number() const</code> for numbers</li>
                                <li><code>const std::string& string() const</code> for strings</li>
                                <li><code>std::string& string_ref()</code> for strings (use this one if you need to directly modify the object and avoid a copy)</li>
                                <li><code>const std::vector&lt;Value&gt;& const_list() const</code> for lists</li>
                                <li><code>std::vector&lt;Value&gt;& list()</code> for lists (use this one if you need to directly modify the object and avoid a copy)</li>
                                <li><code>const UserType& usertype() const</code> for usertypes</li>
                                <li><code>UserType& usertype_ref()</code> for usertypes (use this one if you need to directly modify the object and avoid a copy)</li>
                            </ul>
                        </li>
                        <li>
                            use only if the object is a list:
                            <ul>
                                <li><code>void push_back(const Value&)</code></li>
                                <li><code>void push_back(Value&&)</code></li>
                            </ul>
                        </li>
                        <li><code>std::ostream& operator<<(std::ostream& os, const Value& V)</code> to display the object with <code>std::cout << value;</code></li>
                        <li>
                            <code>bool operator==(const Value& A, const Value& B)</code>,
                            useful to check if the value is nil, true or false: <code>a == Ark::Nil</code>
                            (the two others are <code>Ark::True</code> and <code>Ark::False</code>)
                        </li>
                    </ul>
                </div>
            </section>

            <section id="adding-types">
                <h2>Adding your own types in ArkScript</h2>

                <div class="inner-section">
                    The idea behind this is to be able to use values which can't be held by standard ArkScript values,
                    for example a <code>sf::Image</code> if you are using the SFML.

                    The idea is to have a unique identifier per type (that's only for you as a programmer to know which
                    type you are receiving, ArkScript doesn't care about it), and a value casted as a <code>void*</code> pointer,
                    thus the object <em class="text-bold">needs to continue to exist somewhere</em>.

                    <pre>
<code class="rainbowjs" data-language="c">

enum class Breakfast { Eggs, Bacon, Pizza };

Breakfast& getBreakfast()
{
    static Breakfast bf = Breakfast::Pizza;
    return bf;
}

int main()
{
    Ark::State state;

    state.loadFunction("getBreakfast", [](std::vector&lt;Ark::Value&gt;& n) -> Ark::Value {
        // we need to send the address of the object, which will be casted
        // to void* internally
        Ark::Value v = Ark::Value(Ark::UserType(&getBreakfast()));

        // adding a custom ostream operator
        v.usertype_ref().setOStream([](std::ostream& os, const Ark::UserType& A) -> std::ostream& {
            os << "Breakfast::";
            switch (*static_cast&lt;Breakfast*&gt;(A.data()))
            {
                case Breakfast::Eggs:
                    os << "Eggs";
                    break;

                case Breakfast::Bacon:
                    os << "Bacon";
                    break;

                case Breakfast::Pizza:
                    os << "Pizza";
                    break;

                default:
                    break;
            }
            return os;
        });

        return v;
    });

    state.loadFunction("useBreakfast", [](std::vector&lt;Ark::Value&gt;& n) -> Ark::Value {
        if (n[0].valueType() == Ark::ValueType::User && n[0].usertype().is&lt;Breakfast&gt;())
        {
            std::cout << "UserType detected as an enum class Breakfast" << std::endl;
            Breakfast* ptr = static_cast&lt;Breakfast*&gt;(n[0].usertype().data());
            std::cout << "Got " << n[0].usertype() << "\n";
            if (*ptr == Breakfast::Pizza)
                std::cout << "Good choice! Have a nice breakfast ;)" << std::endl;
        }

        return Ark::Nil;
    });

    state.doString("(begin (let a (getBreakfast)) (print a) (useBreakfast a))");
    Ark::VM vm(&state);
    vm.run();

    /*
        Will print

        Breakfast::Pizza
        UserType detected as an enum class Breakfast
        Got Breakfast::Pizza
        Good choice! Have a nice breakfast ;)
    */

    return 0;
}
</code>
                    </pre>
                </div>
            </section>

            <section id="creating-plugins">
                <h2>Creating plugins</h2>

                <div class="inner-section">
                    Plugins must use the exact same configuration and compiler as the original ArkScript executable, otherwise they won't be loaded properly;
                    thus, it's highly encouraged to compile your module(s) using ArkScript CMakeLists, by putting your module(s) under the folder <code>arkscript/modules</code>
                    and adding it in the CMakeLists of the same folder (you can start by copying the CMakeLists of a module for your own).

                    The supported compilers are:
                    <ul>
                        <li>for Linux: g++-8 (Ubuntu 8.3.0-6ubuntu1~18.04.1) 8.3.0</li>
                        <li>for Windows: MSVC version 19.16.27031.1 for x86 (*nota bene*: even if minor and patch are be different, it should work)</li>
                    </ul>

                    Basic module code:
                    <pre>
<code class="rainbowjs" data-language="c">
// this file includes everything you need for you, and does a using namespace Ark
#include &lt;Ark/Module.hpp&gt;

namespace MyModule
{
    Value foo(std::vector&lt;Value&gt;& args)
    {
        // do stuff
        // ...

        return Nil;
    }
}

// the name mustn't be misspelled, otherwise the ArkVM won't find the plugin entry table
ARK_API_EXPORT Mapping_t getFunctionsMapping()
{
    Mapping_t map;
    // map[name in ArkScript] = C++ function
    map["foo"] = MyModule::foo;
    map["test"] = [](std::vector&lt;Value&gt;& args) {
        // lambdas work too!
        return True;
    };

    return map;
}
</code>
                    </pre>
                </div>
            </section>
        </div>

        <div class="col-2 hide-md"></div>
    </div>
</div>
<!-- END OF CONTENT -->

<!-- FOOTER -->
<footer id="page-footer">
    <p class="text-center">
        Copyright &copy; 2020 Alexandre Plateau & Fabien Zoccola.<br>
        Tous droits réservés
    </p>
</footer>

<!-- Rainbow.js for syntax coloring -->
<script src="/assets/js/rainbow.min.js"></script>
<script src="/assets/js/languages/c.js"></script>

</body>
</html>